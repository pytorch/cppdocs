


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File ivalue.h &mdash; PyTorch master documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://pytorch.org/docs/stable/api/program_listing_file_aten_src_ATen_core_ivalue.h.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/cpp_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/audio/stable/index.html">
                  <span class="dropdown-title">torchaudio</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/text/stable/index.html">
                  <span class="dropdown-title">torchtext</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/vision/stable/index.html">
                  <span class="dropdown-title">torchvision</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/elastic/">
                  <span class="dropdown-title">TorchElastic</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/serve/">
                  <span class="dropdown-title">TorchServe</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/xla">
                  <span class="dropdown-title">PyTorch on XLA Devices</span>
                  <p></p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/features">
                  <span class="dropdown-title">About</span>
                  <p>Learn about PyTorch’s features and capabilities</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/#community-module">
                  <span class="dropdown-title">Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class="dropdown-title">Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/" target="_blank">
                  <span class="dropdown-title">Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/hub">
                  <span class="dropdown-title">Models (Beta)</span>
                  <p>Discover, publish, and reuse pre-trained models</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
                <div class="version">
                  master
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing C++ Distributions of PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../frontend.html">The C++ Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>
<p class="caption"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notes/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_basics.html">Tensor Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_creation.html">Tensor Creation API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_cuda_stream.html">Tensor CUDA Stream API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_indexing.html">Tensor Indexing API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/versioning.html">Library Versioning</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
      <li>Program Listing for File ivalue.h</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            
              <!-- User defined GitHub URL -->
              <a href="https://github.com/pytorch/pytorch" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <div class="section" id="program-listing-for-file-ivalue-h">
<span id="program-listing-file-aten-src-aten-core-ivalue-h"></span><h1>Program Listing for File ivalue.h<a class="headerlink" href="#program-listing-for-file-ivalue-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_aten_src_ATen_core_ivalue.h.html#file-aten-src-aten-core-ivalue-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">aten/src/ATen/core/ivalue.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;ATen/core/TensorBody.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/core/blob.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;c10/util/C++17.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;c10/util/intrusive_ptr.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;torch/csrc/WindowsTorchApiMacro.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;typeindex&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">torch</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">TORCH_API</span> <span class="nl">CustomClassHolder</span> <span class="p">:</span> <span class="k">public</span> <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span> <span class="p">{};</span>
<span class="k">namespace</span> <span class="n">jit</span> <span class="p">{</span>
<span class="k">using</span> <span class="o">::</span><span class="n">torch</span><span class="o">::</span><span class="n">CustomClassHolder</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Function</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">CompilationUnit</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Module</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// namespace jit</span>
<span class="p">}</span> <span class="c1">// namespace torch</span>
<span class="k">namespace</span> <span class="n">c10</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Value</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Dict</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">List</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">IValue</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">ClassType</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Type</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">RRefInterface</span><span class="p">;</span>
<span class="k">using</span> <span class="n">TypePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">ClassType</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ClassTypePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ClassType</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">TORCH_API</span> <span class="kt">bool</span> <span class="n">_fastEqualsForContainer</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

<span class="n">TORCH_API</span> <span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">Function</span><span class="o">*</span> <span class="n">checkObjectSortSchema</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">c10</span><span class="o">::</span><span class="n">ClassTypePtr</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="o">&amp;</span> <span class="n">why_not</span><span class="p">);</span>

<span class="c1">// A comparator that checks ordering of two IValues of same type.</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">IValueComparator</span><span class="p">;</span>

<span class="n">TORCH_API</span> <span class="n">IValueComparator</span> <span class="n">getLessThanComparator</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
<span class="n">TORCH_API</span> <span class="n">IValueComparator</span> <span class="n">getGreaterThanComparator</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>

<span class="k">namespace</span> <span class="n">ivalue</span> <span class="p">{</span>
<span class="k">struct</span> <span class="nc">Tuple</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Future</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">ConstantString</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">GenericDict</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Object</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">PyObjectHolder</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">EnumHolder</span><span class="p">;</span>
<span class="c1">// We need a ComplexHolder because currently the payloads in the Union</span>
<span class="c1">// only take 64 bits. Since ComplexDouble takes up 128 bits, and is too big</span>
<span class="c1">// to fit in the IValue directly, we indirect complex numbers through an intrusive</span>
<span class="c1">// pointer to ComplexHolder (which contains a c10::complex).</span>
<span class="k">struct</span> <span class="nc">ComplexHolder</span> <span class="o">:</span> <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">ComplexHolder</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">convert</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ComplexHolder</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace ivalue</span>

<span class="c1">// This is an owning wrapper for a c10::optional&lt;std::vector&lt;T&gt;&gt;</span>
<span class="c1">// that can be implicitly converted to a (non-owning) optional&lt;ArrayRef&lt;T&gt;&gt;.</span>
<span class="c1">// Its purpose is to be used in generated code to keep the vector alive</span>
<span class="c1">// either until the end of a statement (as a temporary), or as a saved arg</span>
<span class="c1">// in autograd.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">OptionalArray</span> <span class="p">{</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="p">;</span>

  <span class="n">OptionalArray</span><span class="p">(){}</span>
  <span class="n">OptionalArray</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">list</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="p">{}</span>

  <span class="c1">// Used when saving an argument for the backwards pass.</span>
  <span class="n">OptionalArray</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">list</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">list</span> <span class="o">=</span> <span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">operator</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Capsule is an internal implementation detail of custom C++ classes. We</span>
<span class="c1">// define it as an owning wrapper for</span>
<span class="c1">// c10::intrusive_ptr&lt;torch::CustomClassHolder&gt; This wrapper is here to serve as</span>
<span class="c1">// an abstraction of the type erased custom class object pointer. It also allow</span>
<span class="c1">// pybind11 to treat this as a standalone class to register as a separate type</span>
<span class="c1">// caster, instead of a custom pointer holder which the pointer holder type</span>
<span class="c1">// caster try to &quot;unwrap&quot; it automatically.</span>
<span class="k">struct</span> <span class="nc">Capsule</span> <span class="p">{</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">CustomClassHolder</span><span class="o">&gt;</span> <span class="n">obj_ptr</span><span class="p">;</span>
  <span class="k">explicit</span> <span class="nf">Capsule</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">CustomClassHolder</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">obj_ptr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// IValue is the generic tagged union used by the interpreter to hold</span>
<span class="c1">// all value types.</span>
<span class="c1">// It is a 16-byte object with an 8-byte payload and an 8-byte tag.</span>
<span class="c1">// The tag is currently 4 bytes to determine the type, and 1 byte</span>
<span class="c1">// to mark whether that type is a subtype of c10::intrusive_ptr_target and needs</span>
<span class="c1">// retain/release calls.</span>

<span class="cp">#define TORCH_FORALL_TAGS(_) \</span>
<span class="cp">  _(None)                    \</span>
<span class="cp">  _(Tensor)                  \</span>
<span class="cp">  _(Storage)                 \</span>
<span class="cp">  _(Double)                  \</span>
<span class="cp">  _(ComplexDouble)           \</span>
<span class="cp">  _(Int)                     \</span>
<span class="cp">  _(Bool)                    \</span>
<span class="cp">  _(Tuple)                   \</span>
<span class="cp">  _(String)                  \</span>
<span class="cp">  _(Blob)                    \</span>
<span class="cp">  _(GenericList)             \</span>
<span class="cp">  _(GenericDict)             \</span>
<span class="cp">  _(Future)                  \</span>
<span class="cp">  _(Device)                  \</span>
<span class="cp">  _(Stream)                  \</span>
<span class="cp">  _(Object)                  \</span>
<span class="cp">  _(PyObject)                \</span>
<span class="cp">  _(Uninitialized)           \</span>
<span class="cp">  _(Capsule)                 \</span>
<span class="cp">  _(RRef)                    \</span>
<span class="cp">  _(Quantizer)               \</span>
<span class="cp">  _(Generator)               \</span>
<span class="cp">  _(Enum)</span>

<span class="c1">// [doxygen private]</span>
<span class="c1">// These methods are not actually private but we don&#39;t want to document them, so</span>
<span class="c1">// they are marked `@private`, which hides them on the doxygen documentation for</span>
<span class="c1">// this page.</span>

<span class="k">struct</span> <span class="nc">TORCH_API</span> <span class="n">IValue</span> <span class="k">final</span> <span class="p">{</span>
  <span class="n">IValue</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">IValue</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_intrusive_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">!=</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">c10</span><span class="o">::</span><span class="n">raw</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">::</span><span class="n">incref</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">IValue</span><span class="p">(</span><span class="n">IValue</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">moveFrom</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">IValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">destroy</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">C10_ALWAYS_INLINE</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">IValue</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">destroy</span><span class="p">();</span>
    <span class="n">moveFrom</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">IValue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">IValue</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">IValue</span><span class="p">(</span><span class="n">rhs</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">dump</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">IValue</span> <span class="nf">equals</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">TORCH_API</span> <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
  <span class="n">TORCH_API</span> <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">is</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">IValue</span> <span class="nf">hash</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">IValue</span><span class="o">::</span><span class="n">hash</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// This is defined because `c10::hash` dispatches to a function of this</span>
  <span class="c1">// signature. See the member function `hash()`.</span>
  <span class="k">static</span> <span class="kt">size_t</span> <span class="n">hash</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">iv</span><span class="p">);</span>

  <span class="n">TORCH_API</span> <span class="k">friend</span> <span class="kt">bool</span> <span class="n">_fastEqualsForContainer</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">isAliasOf</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Trivially don&#39;t alias if the type is different</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Tensors should be compared based on internal storage</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">thisTensor</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">toTensor</span><span class="p">();</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rhsTensor</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">toTensor</span><span class="p">();</span>
      <span class="k">return</span> <span class="n">thisTensor</span><span class="p">.</span><span class="n">is_alias_of</span><span class="p">(</span><span class="n">rhsTensor</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Primitive types don&#39;t alias anything</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">AT_ASSERT</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">);</span>

    <span class="c1">// Other types can be compared by their ptr value</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">size_t</span> <span class="nf">use_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">==</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">c10</span><span class="o">::</span><span class="n">raw</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">::</span><span class="n">use_count</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTensor</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">);</span>
      <span class="c1">// As far as I can tell, omitting the usual explicit destructor call</span>
      <span class="c1">// is not UB in and of itself, and it&#39;s a slight perf win. The</span>
      <span class="c1">// destructor is a no-op, because the moved-from Tensor is</span>
      <span class="c1">// effectively an intrusive_ptr in the null state, so we don&#39;t need</span>
      <span class="c1">// the behavior for correctness reasons either. Leaving this</span>
      <span class="c1">// explanatory comment, including commented-out destructor call, to</span>
      <span class="c1">// make this abundantly clear.</span>
      <span class="c1">//</span>
      <span class="c1">// payload.as_tensor.~Tensor();</span>
      <span class="n">payload</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">;</span>
      <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">)</span> <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">is_intrusive_ptr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Accessors for subtypes are arranged together below</span>
  <span class="c1">// While some of these accessors could be generated through templates,</span>
  <span class="c1">// we prefer to write them manually for clarity</span>

  <span class="n">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Tensor</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">)</span> <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isTensor</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Tensor</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">toTensor</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&amp;</span> <span class="n">toTensor</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&amp;</span> <span class="n">toTensor</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="n">at</span><span class="o">::</span><span class="n">TensorImpl</span><span class="o">*</span> <span class="n">unsafeToTensorImpl</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">.</span><span class="n">unsafeGetTensorImpl</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Storage</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Storage</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Note: the undefined tensor is not refcounted, so while it</span>
    <span class="c1">// is tagged as a tensor, is_intrusive_ptr is set to false.</span>
    <span class="c1">// This is not an optional optimization: our incref call</span>
    <span class="c1">// *will not* do the right thing when called on an</span>
    <span class="c1">// undefined tensor.</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">=</span> <span class="n">null_to_undefined_tensor</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">unsafeReleaseStorageImpl</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isStorage</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Storage</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">Storage</span> <span class="n">toStorage</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">Storage</span> <span class="n">toStorage</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">toIValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">toIValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">IValue</span><span class="p">(</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">caffe2</span><span class="o">::</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">blob</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Blob</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// TODO (after Tensor merge) If we pass in a Blob holding a Tensor, extract</span>
    <span class="c1">// and store it as a Tensor instead.</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">=</span> <span class="n">null_to_undefined_tensor</span><span class="p">(</span><span class="n">blob</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isBlob</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Blob</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">caffe2</span><span class="o">::</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">toBlob</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>

  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">caffe2</span><span class="o">::</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">toBlob</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Capsule. No new callsites of these APIs should</span>
  <span class="c1">// be introduced.</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="n">IValue</span> <span class="n">make_capsule</span><span class="p">(</span>
      <span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">CustomClassHolder</span><span class="o">&gt;</span> <span class="n">blob</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isCapsule</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Capsule</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">CustomClassHolder</span><span class="o">&gt;</span> <span class="n">toCapsule</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">CustomClassHolder</span><span class="o">&gt;</span> <span class="n">toCapsule</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Custom C++ classes</span>
  <span class="k">template</span> <span class="o">&lt;</span>
      <span class="k">typename</span> <span class="nc">T</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
          <span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">CustomClassHolder</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
          <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">custom_class</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isCustomClass</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">toCustomClass</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">toCustomClass</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Tuple</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span>
      <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
          <span class="o">!</span><span class="n">guts</span><span class="o">::</span><span class="n">disjunction</span><span class="o">&lt;</span>
              <span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">...,</span>
              <span class="n">guts</span><span class="o">::</span><span class="n">negation</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="n">IValue</span><span class="p">,</span> <span class="n">Args</span><span class="o">&gt;&gt;</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isTuple</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Tuple</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">toTuple</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">toTuple</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Double</span>
  <span class="n">IValue</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Double</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_double</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isDouble</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Double</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">double</span> <span class="n">toDouble</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">AT_ASSERT</span><span class="p">(</span><span class="n">isDouble</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_double</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ComplexDouble</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isComplexDouble</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">ComplexDouble</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">toComplexDouble</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Future</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Future</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isFuture</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Future</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Future</span><span class="o">&gt;</span> <span class="n">toFuture</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Future</span><span class="o">&gt;</span> <span class="n">toFuture</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// RRef</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">RRefInterface</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isRRef</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">RRef</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">RRefInterface</span><span class="o">&gt;</span> <span class="n">toRRef</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">RRefInterface</span><span class="o">&gt;</span> <span class="n">toRRef</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Quantizer</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Quantizer</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isQuantizer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Quantizer</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Quantizer</span><span class="o">&gt;</span> <span class="n">toQuantizer</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Quantizer</span><span class="o">&gt;</span> <span class="n">toQuantizer</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Int</span>
  <span class="n">IValue</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Int</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_int</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// allow you to pass literals (3, 4) without ambiguity</span>
  <span class="n">IValue</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">IValue</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">isInt</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Int</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int64_t</span> <span class="n">toInt</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">AT_ASSERT</span><span class="p">(</span><span class="n">isInt</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_int</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Bool</span>
  <span class="n">IValue</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Bool</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(__clang__) &amp;&amp; defined(__x86_64__)</span>
    <span class="c1">// Initializing entire payload stops valgrind&#39;s from reporting</span>
    <span class="c1">// &quot;jump or move depends on uninitialised value&quot; in IValue copy constructor</span>
    <span class="c1">// See https://github.com/pytorch/pytorch/issues/37117</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_int</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_bool</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isBool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Bool</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">toBool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">AT_ASSERT</span><span class="p">(</span><span class="n">isBool</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_bool</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// IntList</span>
  <span class="kt">bool</span> <span class="n">isIntList</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">toIntList</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">toIntList</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">toIntVector</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// ConstantString</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">ConstantString</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">v</span><span class="p">);</span>
  <span class="n">IValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">IValue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{}</span>
  <span class="kt">bool</span> <span class="n">isString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">String</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">ConstantString</span><span class="o">&gt;</span> <span class="n">toString</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">ConstantString</span><span class="o">&gt;</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">toStringRef</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">toOptionalStringRef</span><span class="p">()</span>
      <span class="k">const</span><span class="p">;</span>

  <span class="c1">// DoubleList</span>
  <span class="kt">bool</span> <span class="nf">isDoubleList</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">toDoubleList</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">toDoubleList</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">toDoubleVector</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// ComplexDoubleList</span>
  <span class="kt">bool</span> <span class="nf">isComplexDoubleList</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">toComplexDoubleList</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">toComplexDoubleList</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">toComplexDoubleVector</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// BoolList</span>
  <span class="kt">bool</span> <span class="nf">isBoolList</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">toBoolList</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">toBoolList</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// TensorList</span>
  <span class="kt">bool</span> <span class="nf">isTensorList</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">toTensorList</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">toTensorList</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">toTensorVector</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// GenericList</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">IValue</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isList</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">GenericList</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">IValue</span><span class="o">&gt;</span> <span class="n">toList</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">IValue</span><span class="o">&gt;</span> <span class="n">toList</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">IValue</span><span class="o">&gt;</span> <span class="n">toListRef</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Some template constructors of IValue calls another constructor recursively.</span>
  <span class="c1">// This SNIFAEs the called constructor exists.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">enable_if_ivalue_constructible</span> <span class="o">=</span>
      <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="n">IValue</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">enable_if_ivalue_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">enable_if_ivalue_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">enable_if_ivalue_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

  <span class="c1">// GenericDict</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">Dict</span><span class="o">&lt;</span><span class="n">IValue</span><span class="p">,</span> <span class="n">IValue</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isGenericDict</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">GenericDict</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">Dict</span><span class="o">&lt;</span><span class="n">IValue</span><span class="p">,</span> <span class="n">IValue</span><span class="o">&gt;</span> <span class="n">toGenericDict</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">Dict</span><span class="o">&lt;</span><span class="n">IValue</span><span class="p">,</span> <span class="n">IValue</span><span class="o">&gt;</span> <span class="n">toGenericDict</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Value</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">Dict</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Value</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Value</span><span class="o">&gt;</span>
  <span class="n">C10_DEPRECATED_MESSAGE</span><span class="p">(</span>
      <span class="s">&quot;IValues based on std::unordered_map&lt;K, V&gt; are slow and deprecated. Please use c10::Dict&lt;K, V&gt; instead.&quot;</span><span class="p">)</span>
      <span class="n">IValue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Value</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">enable_if_ivalue_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt_t</span><span class="p">);</span>

  <span class="c1">// ClassType</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isObject</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Object</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">toObject</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">toObject</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">ivalue</span><span class="o">::</span><span class="n">Object</span><span class="o">&amp;</span> <span class="n">toObjectRef</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">Module</span> <span class="n">toModule</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">isModule</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// PyObject</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">PyObjectHolder</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isPyObject</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">PyObject</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">PyObjectHolder</span><span class="o">&gt;</span> <span class="n">toPyObjectHolder</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">PyObjectHolder</span><span class="o">&gt;</span> <span class="n">toPyObjectHolder</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
  <span class="n">PyObject</span><span class="o">*</span> <span class="nf">toPyObject</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Enum</span>
  <span class="k">explicit</span> <span class="nf">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">EnumHolder</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">isEnum</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Enum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">EnumHolder</span><span class="o">&gt;</span> <span class="n">toEnumHolder</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">ivalue</span><span class="o">::</span><span class="n">EnumHolder</span><span class="o">&gt;</span> <span class="n">toEnumHolder</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// None</span>
  <span class="n">IValue</span><span class="p">()</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">None</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">bool</span> <span class="n">isNone</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">None</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toNone</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">AT_ASSERT</span><span class="p">(</span><span class="n">isNone</span><span class="p">());</span>
    <span class="k">return</span> <span class="s">&quot;None&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">IValue</span> <span class="n">uninitialized</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">IValue</span><span class="p">();</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Uninitialized</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Scalar, which gets encoded as either an Int, a Double or a ComplexDouble</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">IValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">isFloatingPoint</span><span class="p">())</span> <span class="p">{</span>
      <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">toDouble</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">isComplex</span><span class="p">())</span> <span class="p">{</span>
      <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">toComplexDouble</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">toLong</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isScalar</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">isDouble</span><span class="p">()</span> <span class="o">||</span> <span class="n">isInt</span><span class="p">()</span> <span class="o">||</span> <span class="n">isComplexDouble</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">at</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">toScalar</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isDouble</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">toDouble</span><span class="p">();</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isInt</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">toInt</span><span class="p">();</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isComplexDouble</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">toComplexDouble</span><span class="p">();</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;IValue is not a Scalar&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Device</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">Device</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Device</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_device</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">type</span><span class="p">();</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_device</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">index</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isDevice</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Device</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">Device</span> <span class="n">toDevice</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">AT_ASSERT</span><span class="p">(</span><span class="n">isDevice</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">c10</span><span class="o">::</span><span class="n">Device</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_device</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_device</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//Stream</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">Stream</span> <span class="n">stream</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Stream</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_int</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">pack</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">Stream</span> <span class="n">toStream</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">Stream</span> <span class="n">toStream</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">isStream</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Stream</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// ScalarType</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">ScalarType</span> <span class="n">t</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">IValue</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">at</span><span class="o">::</span><span class="n">ScalarType</span> <span class="n">toScalarType</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">toInt</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// Layout</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">Layout</span> <span class="n">l</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">IValue</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">at</span><span class="o">::</span><span class="n">Layout</span> <span class="n">toLayout</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Layout</span><span class="o">&gt;</span><span class="p">(</span><span class="n">toInt</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// MemoryFormat</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">MemoryFormat</span> <span class="n">m</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">IValue</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">at</span><span class="o">::</span><span class="n">MemoryFormat</span> <span class="n">toMemoryFormat</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">MemoryFormat</span><span class="o">&gt;</span><span class="p">(</span><span class="n">toInt</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// QScheme</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">QScheme</span> <span class="n">qscheme</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Int</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_int</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">qscheme</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">at</span><span class="o">::</span><span class="n">QScheme</span> <span class="n">toQScheme</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">QScheme</span><span class="o">&gt;</span><span class="p">(</span><span class="n">toInt</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// Dimname</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Dimname</span> <span class="n">dimname</span><span class="p">)</span> <span class="o">:</span> <span class="n">IValue</span><span class="p">(</span><span class="n">dimname</span><span class="p">.</span><span class="n">symbol</span><span class="p">().</span><span class="n">toQualString</span><span class="p">())</span> <span class="p">{}</span>

  <span class="n">at</span><span class="o">::</span><span class="n">Dimname</span> <span class="n">toDimname</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">at</span><span class="o">::</span><span class="n">Dimname</span><span class="o">::</span><span class="n">fromSymbol</span><span class="p">(</span><span class="n">Symbol</span><span class="o">::</span><span class="n">fromQualString</span><span class="p">(</span><span class="n">toStringRef</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="c1">// Generator</span>
  <span class="n">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Generator</span> <span class="n">g</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">Tag</span><span class="o">::</span><span class="n">Generator</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">defined</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Note: the undefined generator is not refcounted, so while it</span>
    <span class="c1">// is tagged as a generator, is_intrusive_ptr is set to false.</span>
    <span class="c1">// This is not an optional optimization: our incref call</span>
    <span class="c1">// *will not* do the right thing when called on an</span>
    <span class="c1">// undefined generator.</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">=</span> <span class="n">null_to_undefined_tensor</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">unsafeReleaseGeneratorImpl</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isGenerator</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">Generator</span> <span class="o">==</span> <span class="n">tag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">at</span><span class="o">::</span><span class="n">Generator</span> <span class="n">toGenerator</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">at</span><span class="o">::</span><span class="n">Generator</span> <span class="n">toGenerator</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// for debugging</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tagKind</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#define DEFINE_CASE(x) \</span>
<span class="cp">  case Tag::x:         \</span>
<span class="cp">    return #x;</span>
      <span class="n">TORCH_FORALL_TAGS</span><span class="p">(</span><span class="n">DEFINE_CASE</span><span class="p">)</span>
<span class="cp">#undef DEFINE_CASE</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;InvalidTag(&quot;</span> <span class="o">+</span> <span class="n">c10</span><span class="o">::</span><span class="n">guts</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// generic v.to&lt;at::Tensor&gt;() implementations</span>
  <span class="c1">// that can be used in special functions like pop/push</span>
  <span class="c1">// that use template meta-programming.</span>
  <span class="c1">// prefer the directly named methods when you can,</span>
  <span class="c1">// since they are simpler to understand</span>

  <span class="c1">// Note: if you get linker errors saying one of these is missing,</span>
  <span class="c1">// change it to ... &amp;&amp; = delete; and you will see better error messages for</span>
  <span class="c1">// why However, we cannot commit this because some compiler versions barf on</span>
  <span class="c1">// it.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">T</span> <span class="n">to</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">T</span> <span class="n">to</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// ToOptional: convert a IValue to the Optional obj that accepts both T and</span>
  <span class="c1">// None</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">toOptional</span><span class="p">();</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">toOptional</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">isSameIdentity</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Computes the &quot;official&quot; string representation of an IValue. This produces a</span>
  <span class="c1">// TorchScript expression that can be used to recreate an IValue with the same</span>
  <span class="c1">// value (e.g. when we are printing constants in the serializer).</span>
  <span class="c1">//</span>
  <span class="c1">// Callers can use `customFormatter` to override how `repr()` prints out an</span>
  <span class="c1">// IValue. This is useful if you have some other environment where you can</span>
  <span class="c1">// look up values, and you want to print a reference to that environment (like</span>
  <span class="c1">// the serializer&#39;s constant table).</span>
  <span class="c1">//</span>
  <span class="c1">// repr() is not necessarily defined on all objects!</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">repr</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">customFormatter</span><span class="p">)</span>
      <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Computes an &quot;informal&quot; string representation of an IValue. This should be</span>
  <span class="c1">// used for debugging, or servicing `print()`-like functions.</span>
  <span class="c1">// This is different from `repr()` in that there is no expectation that we can</span>
  <span class="c1">// exactly reconstruct an IValue from the output; feel free to use a</span>
  <span class="c1">// concise/pretty form</span>
  <span class="n">TORCH_API</span> <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">isPtrType</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">isTensor</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">.</span><span class="n">defined</span><span class="p">())</span> <span class="o">||</span> <span class="n">is_intrusive_ptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">internalToPointer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">TORCH_INTERNAL_ASSERT</span><span class="p">(</span>
        <span class="n">isPtrType</span><span class="p">(),</span> <span class="s">&quot;Can only call internalToPointer() for pointer types&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">.</span><span class="n">unsafeGetTensorImpl</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">!=</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">()</span>
        <span class="o">?</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="nl">as_intrusive_ptr</span> <span class="p">:</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">TypePtr</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Detect aliased tensors.</span>
  <span class="k">struct</span> <span class="nc">HashAliasedIValue</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">val</span><span class="p">.</span><span class="n">toTensor</span><span class="p">().</span><span class="n">storage</span><span class="p">().</span><span class="n">unsafeGetStorageImpl</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="c1">// If it is not a Tensor, then two mutable IValues alias each other only</span>
      <span class="c1">// if they are the same pointer.</span>
      <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_int</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">struct</span> <span class="nc">CompAliasedIValues</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isAliasOf</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">using</span> <span class="n">HashAliasedIValues</span> <span class="o">=</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">IValue</span><span class="p">,</span> <span class="n">HashAliasedIValue</span><span class="p">,</span> <span class="n">CompAliasedIValues</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">HashAliasedIValueMap</span> <span class="o">=</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">IValue</span><span class="p">,</span> <span class="n">IValue</span><span class="p">,</span> <span class="n">HashAliasedIValue</span><span class="p">,</span> <span class="n">CompAliasedIValues</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="c1">// Chechs if this and rhs has a subvalues in common.</span>
  <span class="c1">// [t1,t2] and [t2, t3] returns true.</span>
  <span class="kt">bool</span> <span class="nf">overlaps</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Inserts all subvalues of this in subValues.</span>
  <span class="kt">void</span> <span class="nf">getSubValues</span><span class="p">(</span><span class="n">HashAliasedIValues</span><span class="o">&amp;</span> <span class="n">subValues</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Apply visitor to every subvalue.</span>
  <span class="c1">// TODO: There are several places that recurse over IValue. This is fragile.</span>
  <span class="c1">// This visitor should be used to recurse over ivalues.</span>
  <span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">IValue</span> <span class="nf">deepcopy</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">IValue</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">HashAliasedIValueMap</span><span class="o">&amp;</span> <span class="n">memo</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="o">*</span> <span class="n">null_to_undefined_tensor</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">?</span> <span class="nl">p</span> <span class="p">:</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">bool</span> <span class="n">ptrEqual</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
  <span class="c1">// NOTE: IValue tags are intentionally private. In the future we may encode</span>
  <span class="c1">// this value different (e.g. using NaN boxing), and this would make it more</span>
  <span class="c1">// costly to determine the tag for all types vs just determining if something</span>
  <span class="c1">// is a particular type. Instead we want clients to use the `isX` methods when</span>
  <span class="c1">// possible. If for perf. reasons you really, absolutely, must have a jump</span>
  <span class="c1">// table, then we can revisit this.</span>
  <span class="k">enum</span> <span class="k">class</span> <span class="nc">Tag</span> <span class="o">:</span> <span class="kt">uint32_t</span> <span class="p">{</span>
<span class="cp">#define DEFINE_TAG(x) x,</span>
    <span class="n">TORCH_FORALL_TAGS</span><span class="p">(</span><span class="n">DEFINE_TAG</span><span class="p">)</span>
<span class="cp">#undef DEFINE_TAG</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span>
      <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
      <span class="k">class</span> <span class="nc">NullType</span> <span class="o">=</span> <span class="n">c10</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">intrusive_target_default_null_type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">NullType</span><span class="o">&gt;</span> <span class="n">moveToIntrusivePtr</span><span class="p">();</span>
  <span class="k">template</span> <span class="o">&lt;</span>
      <span class="k">typename</span> <span class="nc">T</span><span class="p">,</span>
      <span class="k">class</span> <span class="nc">NullType</span> <span class="o">=</span> <span class="n">c10</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">intrusive_target_default_null_type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
  <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">NullType</span><span class="o">&gt;</span> <span class="n">toIntrusivePtr</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// We carefully construct this call to both 1) avoid UB by using</span>
    <span class="c1">// the &quot;wrong&quot; one of as_tensor and as_intrusive_ptr and 2) enable</span>
    <span class="c1">// the compiler to generate the same code for each case. It is</span>
    <span class="c1">// surprisingly difficult to get this right.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTensor</span><span class="p">()</span> <span class="o">||</span> <span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">isTensor</span><span class="p">()</span> <span class="o">?</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">.</span><span class="n">unsafeGetTensorImpl</span><span class="p">()</span> <span class="o">:</span> <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">;</span>
      <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">intrusive_ptr_target</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">&gt;::</span><span class="n">reclaim</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
      <span class="c1">// No need to make this destructor call!</span>
      <span class="c1">// payload.as_tensor.~Tensor();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">C10_ALWAYS_INLINE</span> <span class="kt">void</span> <span class="n">moveFrom</span><span class="p">(</span><span class="n">IValue</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">)</span> <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">));</span>
      <span class="c1">// As far as I can tell, omitting the usual explicit destructor call</span>
      <span class="c1">// is not UB in and of itself, and it&#39;s a slight perf win. The</span>
      <span class="c1">// destructor is a no-op, because the moved-from Tensor is</span>
      <span class="c1">// effectively an intrusive_ptr in the null state, so we don&#39;t need</span>
      <span class="c1">// the behavior for correctness reasons either. Leaving this</span>
      <span class="c1">// explanatory comment, including commented-out destructor call, to</span>
      <span class="c1">// make this abundantly clear.</span>
      <span class="c1">//</span>
      <span class="c1">// rhs.payload.as_tensor.~Tensor();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">payload</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">;</span>
    <span class="n">is_intrusive_ptr</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">;</span>
    <span class="n">rhs</span><span class="p">.</span><span class="n">clearToNone</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">clearToNone</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>
    <span class="n">is_intrusive_ptr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">union</span> <span class="nc">Payload</span> <span class="p">{</span>
    <span class="c1">// We use a nested union here so that we can make the copy easy</span>
    <span class="c1">// and efficient in the non-tensor (i.e., trivially copyable)</span>
    <span class="c1">// case. Specifically, we do not have to do a switch-on-tag to</span>
    <span class="c1">// figure out which union member to assign; we can just use</span>
    <span class="c1">// TriviallyCopyablePayload::operator=.</span>
    <span class="k">union</span> <span class="nc">TriviallyCopyablePayload</span> <span class="p">{</span>
      <span class="n">TriviallyCopyablePayload</span><span class="p">()</span> <span class="o">:</span> <span class="n">as_int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
      <span class="kt">int64_t</span> <span class="n">as_int</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">as_double</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">as_bool</span><span class="p">;</span>
      <span class="c1">// Invariant: never nullptr; null state is represented as</span>
      <span class="c1">// c10::UndefinedTensorImpl::singleton() for consistency of</span>
      <span class="c1">// representation with Tensor.</span>
      <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="o">*</span> <span class="n">as_intrusive_ptr</span><span class="p">;</span>
      <span class="k">struct</span> <span class="p">{</span>
        <span class="n">DeviceType</span> <span class="n">type</span><span class="p">;</span>
        <span class="n">DeviceIndex</span> <span class="n">index</span><span class="p">;</span>
      <span class="p">}</span> <span class="n">as_device</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">as_tensor</span><span class="p">;</span>
    <span class="n">Payload</span><span class="p">()</span> <span class="o">:</span> <span class="n">u</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">Payload</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="n">IValue</span><span class="p">(</span><span class="k">const</span> <span class="n">Payload</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="n">Tag</span> <span class="n">t</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">)</span> <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">payload</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">Payload</span> <span class="n">payload</span><span class="p">;</span>
  <span class="n">Tag</span> <span class="n">tag</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">is_intrusive_ptr</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">struct</span> <span class="nc">WeakIValue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">TORCH_API</span> <span class="n">WeakIValue</span> <span class="k">final</span> <span class="p">{</span>
  <span class="n">WeakIValue</span><span class="p">()</span> <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">IValue</span><span class="o">::</span><span class="n">Tag</span><span class="o">::</span><span class="n">None</span><span class="p">),</span> <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">WeakIValue</span><span class="p">(</span><span class="k">const</span> <span class="n">WeakIValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">payload</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">),</span>
        <span class="n">tag</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">),</span>
        <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_intrusive_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">!=</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">c10</span><span class="o">::</span><span class="n">raw</span><span class="o">::</span><span class="n">weak_intrusive_ptr</span><span class="o">::</span><span class="n">incref</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">WeakIValue</span><span class="p">(</span><span class="k">const</span> <span class="n">IValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">),</span>
        <span class="n">is_intrusive_ptr</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">isTensor</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">unsafeToTensorImpl</span><span class="p">();</span>
      <span class="n">is_intrusive_ptr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">payload</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">u</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">!=</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">c10</span><span class="o">::</span><span class="n">raw</span><span class="o">::</span><span class="n">weak_intrusive_ptr</span><span class="o">::</span><span class="n">incref</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">WeakIValue</span><span class="p">(</span><span class="n">WeakIValue</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">WeakIValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">WeakIValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_intrusive_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">!=</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">c10</span><span class="o">::</span><span class="n">raw</span><span class="o">::</span><span class="n">weak_intrusive_ptr</span><span class="o">::</span><span class="n">decref</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">WeakIValue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">WeakIValue</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">WeakIValue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">)).</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this also sets rhs to None</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">WeakIValue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">WeakIValue</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">WeakIValue</span><span class="p">(</span><span class="n">rhs</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">WeakIValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">is_intrusive_ptr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tag</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isSameIdentity</span><span class="p">(</span><span class="k">const</span> <span class="n">WeakIValue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_int</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">as_int</span> <span class="o">&amp;&amp;</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tag</span> <span class="o">&amp;&amp;</span>
        <span class="n">is_intrusive_ptr</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">is_intrusive_ptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">IValue</span> <span class="n">lock</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">IValue</span><span class="o">::</span><span class="n">Payload</span> <span class="n">newPayload</span><span class="p">;</span>
      <span class="n">newPayload</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">payload</span><span class="p">;</span>
      <span class="k">return</span> <span class="nf">IValue</span><span class="p">(</span><span class="n">newPayload</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IValue</span><span class="o">::</span><span class="n">Tag</span><span class="o">::</span><span class="n">Tensor</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">c10</span><span class="o">::</span><span class="n">weak_intrusive_ptr</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">TensorImpl</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">&gt;::</span><span class="n">reclaim</span><span class="p">(</span>
          <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">TensorImpl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">));</span>
      <span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">TensorImpl</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">&gt;</span> <span class="n">ip</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">lock</span><span class="p">());</span>
      <span class="n">temp</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">IValue</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">IValue</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ip</span><span class="p">)));</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">c10</span><span class="o">::</span><span class="n">weak_intrusive_ptr</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="o">&gt;::</span><span class="n">reclaim</span><span class="p">(</span>
          <span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">==</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">::</span><span class="n">singleton</span><span class="p">()</span>
          <span class="o">?</span> <span class="k">nullptr</span>
          <span class="o">:</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
      <span class="n">IValue</span><span class="o">::</span><span class="n">Payload</span> <span class="n">pl</span><span class="p">;</span>
      <span class="n">pl</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">release</span><span class="p">();</span>
      <span class="n">temp</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pl</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">IValue</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">IValue</span><span class="p">(</span><span class="n">pl</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">use_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">c10</span><span class="o">::</span><span class="n">weak_intrusive_ptr</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">&gt;::</span><span class="n">reclaim</span><span class="p">(</span>
        <span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
    <span class="n">temp</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">weak_use_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_intrusive_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">c10</span><span class="o">::</span><span class="n">weak_intrusive_ptr</span><span class="o">&lt;</span><span class="n">c10</span><span class="o">::</span><span class="n">intrusive_ptr_target</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">UndefinedTensorImpl</span><span class="o">&gt;::</span><span class="n">reclaim</span><span class="p">(</span>
        <span class="n">payload</span><span class="p">.</span><span class="n">as_intrusive_ptr</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">weak_use_count</span><span class="p">();</span>
    <span class="n">temp</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">size_t</span> <span class="n">hash</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">payload</span><span class="p">.</span><span class="n">as_int</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">Payload</span> <span class="o">=</span> <span class="n">IValue</span><span class="o">::</span><span class="n">Payload</span><span class="o">::</span><span class="n">TriviallyCopyablePayload</span><span class="p">;</span>
  <span class="n">Payload</span> <span class="n">payload</span><span class="p">;</span>
  <span class="n">IValue</span><span class="o">::</span><span class="n">Tag</span> <span class="n">tag</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">is_intrusive_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// An owning pointer to a type. When the type is class type, it requires a pair</span>
<span class="c1">// of shared_ptrs to the class type and its owning CU, so that the class type is</span>
<span class="c1">// guaranteed to stay alive as long as we hold this object.</span>
<span class="k">struct</span> <span class="nc">TORCH_API</span> <span class="n">StrongTypePtr</span> <span class="p">{</span>
  <span class="n">StrongTypePtr</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">CompilationUnit</span><span class="o">&gt;</span> <span class="n">cu</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">CompilationUnit</span><span class="o">&gt;</span> <span class="n">cu_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">type_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">TORCH_API</span> <span class="n">ska</span><span class="o">::</span><span class="n">flat_hash_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">ClassTypePtr</span><span class="o">&gt;&amp;</span>
<span class="n">getCustomClassTypeMap</span><span class="p">();</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">c10</span><span class="o">::</span><span class="n">ClassTypePtr</span> <span class="n">getCustomClassTypeImpl</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">tmap</span> <span class="o">=</span> <span class="n">c10</span><span class="o">::</span><span class="n">getCustomClassTypeMap</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">tmap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">)));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">tmap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">c10</span><span class="o">::</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Can&#39;t find class id in custom class type map&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">c10</span><span class="o">::</span><span class="n">ClassTypePtr</span><span class="o">&amp;</span> <span class="n">getCustomClassType</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Classes are never unregistered from getCustomClassTypeMap and the</span>
  <span class="c1">// hash lookup can be a hot path, so just cache.</span>
  <span class="c1">// For the same reason, it&#39;s fine If this ends up getting duplicated across</span>
  <span class="c1">// DSO boundaries for whatever reason.</span>
  <span class="k">static</span> <span class="n">c10</span><span class="o">::</span><span class="n">ClassTypePtr</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">getCustomClassTypeImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TORCH_API</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">PyObject</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">getClassConverter</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// namespace c10</span>

<span class="cp">#include</span> <span class="cpf">&lt;ATen/core/ivalue_inl.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div>


             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Torch Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Program Listing for File ivalue.h</a></li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script src="../_static/jquery.js"></script>
         <script src="../_static/underscore.js"></script>
         <script src="../_static/doctools.js"></script>
         <script src="../_static/language_data.js"></script>
         <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
         <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/resources">Resources</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf" target="_blank">Brand Guidelines</a></li>
          </ul>
        </div>

        <div class="footer-links-col follow-us-col">
          <ul>
            <li class="list-title">Stay Connected</li>
            <li>
              <div id="mc_embed_signup">
                <form
                  action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&id=91d0dccd39"
                  method="post"
                  id="mc-embedded-subscribe-form"
                  name="mc-embedded-subscribe-form"
                  class="email-subscribe-form validate"
                  target="_blank"
                  novalidate>
                  <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
                    <div class="mc-field-group">
                      <label for="mce-EMAIL" style="display:none;">Email Address</label>
                      <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
                    </div>

                    <div id="mce-responses" class="clear">
                      <div class="response" id="mce-error-response" style="display:none"></div>
                      <div class="response" id="mce-success-response" style="display:none"></div>
                    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->

                    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

                    <div class="clear">
                      <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
                    </div>
                  </div>
                </form>
              </div>

            </li>
          </ul>

          <div class="footer-social-icons">
            <a href="https://www.facebook.com/pytorch" target="_blank" class="facebook"></a>
            <a href="https://twitter.com/pytorch" target="_blank" class="twitter"></a>
            <a href="https://www.youtube.com/pytorch" target="_blank" class="youtube"></a>
          </div>
        </div>
      </div>
    </div>
  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/hub">PyTorch Hub</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="resources-mobile-menu-title" class="active">
            Docs
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="https://pytorch.org/audio/stable/index.html">torchaudio</a>
            </li>

            <li>
              <a href="https://pytorch.org/text/stable/index.html">torchtext</a>
            </li>

            <li>
              <a href="https://pytorch.org/vision/stable/index.html">torchvision</a>
            </li>

            <li>
              <a href="https://pytorch.org/elastic/">TorchElastic</a>
            </li>

            <li>
              <a href="https://pytorch.org/serve/">TorchServe</a>
            </li>

            <li>
              <a href="https://pytorch.org/xla">PyTorch on XLA Devices</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            Resources
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/resources">Developer Resources</a>
            </li>

            <li>
              <a href="https://pytorch.org/features">About</a>
            </li>

            <li>
              <a href="https://pytorch.org/hub">Models (Beta)</a>
            </li>

            <li>
              <a href="https://pytorch.org/#community-module">Community</a>
            </li>

            <li>
              <a href="https://discuss.pytorch.org/">Forums</a>
            </li>
          </ul>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>