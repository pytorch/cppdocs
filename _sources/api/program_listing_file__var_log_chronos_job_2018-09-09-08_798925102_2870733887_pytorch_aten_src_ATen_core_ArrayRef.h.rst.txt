:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file__var_log_chronos_job_2018-09-09-08_798925102_2870733887_pytorch_aten_src_ATen_core_ArrayRef.h:

Program Listing for File ArrayRef.h
===================================

- Return to documentation for :ref:`file__var_log_chronos_job_2018-09-09-08_798925102_2870733887_pytorch_aten_src_ATen_core_ArrayRef.h`

.. code-block:: cpp

   //===--- ArrayRef.h - Array Reference Wrapper -------------------*- C++ -*-===//
   //
   //                     The LLVM Compiler Infrastructure
   //
   // This file is distributed under the University of Illinois Open Source
   // License. See LICENSE.TXT for details.
   //
   //===----------------------------------------------------------------------===//
   
   // ATen: modified from llvm::ArrayRef.
   // removed llvm-specific functionality
   // removed some implicit const -> non-const conversions that rely on
   // complicated std::enable_if meta-programming
   // removed a bunch of slice variants for simplicity...
   
   #pragma once
   
   #include <ATen/core/C++17.h>
   #include <ATen/core/Error.h>
   #include <ATen/core/SmallVector.h>
   
   #include <array>
   #include <iterator>
   #include <vector>
   
   namespace at {
   
   template <typename T>
   class ArrayRef final {
    public:
     using iterator = const T*;
     using const_iterator = const T*;
     using size_type = size_t;
   
     using reverse_iterator = std::reverse_iterator<iterator>;
   
    private:
     const T* Data;
   
     size_type Length;
   
    public:
   
     /* implicit */ constexpr ArrayRef() : Data(nullptr), Length(0) {}
   
     // TODO Make this explicit
     constexpr ArrayRef(const T& OneElt) : Data(&OneElt), Length(1) {}
   
     constexpr ArrayRef(const T* data, size_t length)
         : Data(data), Length(length) {}
   
     constexpr ArrayRef(const T* begin, const T* end)
         : Data(begin), Length(end - begin) {}
   
     template <typename U>
     /* implicit */ ArrayRef(const SmallVectorTemplateCommon<T, U>& Vec)
         : Data(Vec.data()), Length(Vec.size()) {}
   
     template <typename A>
     /* implicit */ ArrayRef(const std::vector<T, A>& Vec)
         : Data(Vec.data()), Length(Vec.size()) {}
   
     template <size_t N>
     /* implicit */ constexpr ArrayRef(const std::array<T, N>& Arr)
         : Data(Arr.data()), Length(N) {}
   
     template <size_t N>
     /* implicit */ constexpr ArrayRef(const T (&Arr)[N]) : Data(Arr), Length(N) {}
   
     /* implicit */ constexpr ArrayRef(const std::initializer_list<T>& Vec)
         : Data(Vec.begin() == Vec.end() ? static_cast<T*>(nullptr) : Vec.begin()),
           Length(Vec.size()) {}
   
   
     constexpr iterator begin() const {
       return Data;
     }
     constexpr iterator end() const {
       return Data + Length;
     }
   
     constexpr reverse_iterator rbegin() const {
       return reverse_iterator(end());
     }
     constexpr reverse_iterator rend() const {
       return reverse_iterator(begin());
     }
   
     constexpr bool empty() const {
       return Length == 0;
     }
   
     constexpr const T* data() const {
       return Data;
     }
   
     constexpr size_t size() const {
       return Length;
     }
   
     AT_CPP14_CONSTEXPR const T& front() const {
       AT_CHECK(!empty(), "ArrayRef: attempted to access front() of empty list");
       return Data[0];
     }
   
     AT_CPP14_CONSTEXPR const T& back() const {
       AT_CHECK(!empty(), "ArrayRef: attempted to access back() of empty list");
       return Data[Length - 1];
     }
   
     constexpr bool equals(ArrayRef RHS) const {
       return Length == RHS.Length && std::equal(begin(), end(), RHS.begin());
     }
   
     AT_CPP14_CONSTEXPR ArrayRef<T> slice(size_t N, size_t M) const {
       AT_CHECK(
           N + M <= size(),
           "ArrayRef: invalid slice, N = ",
           N,
           "; M = ",
           M,
           "; size = ",
           size());
       return ArrayRef<T>(data() + N, M);
     }
   
     constexpr ArrayRef<T> slice(size_t N) const {
       return slice(N, size() - N);
     }
   
     constexpr const T& operator[](size_t Index) const {
       return Data[Index];
     }
   
     AT_CPP14_CONSTEXPR const T& at(size_t Index) const {
       AT_CHECK(
           Index < Length,
           "ArrayRef: invalid index Index = ",
           Index,
           "; Length = ",
           Length);
       return Data[Index];
     }
   
     template <typename U>
     typename std::enable_if<std::is_same<U, T>::value, ArrayRef<T>>::type&
     operator=(U&& Temporary) = delete;
   
     template <typename U>
     typename std::enable_if<std::is_same<U, T>::value, ArrayRef<T>>::type&
     operator=(std::initializer_list<U>) = delete;
   
     std::vector<T> vec() const {
       return std::vector<T>(Data, Data + Length);
     }
   
   };
   
   } // namespace at
