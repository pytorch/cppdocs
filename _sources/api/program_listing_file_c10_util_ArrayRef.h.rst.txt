:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file_c10_util_ArrayRef.h:

Program Listing for File ArrayRef.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_c10_util_ArrayRef.h>` (``c10/util/ArrayRef.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //===--- ArrayRef.h - Array Reference Wrapper -------------------*- C++ -*-===//
   //
   //                     The LLVM Compiler Infrastructure
   //
   // This file is distributed under the University of Illinois Open Source
   // License. See LICENSE.TXT for details.
   //
   //===----------------------------------------------------------------------===//
   
   // ATen: modified from llvm::ArrayRef.
   // removed llvm-specific functionality
   // removed some implicit const -> non-const conversions that rely on
   // complicated std::enable_if meta-programming
   // removed a bunch of slice variants for simplicity...
   
   #pragma once
   
   #include <c10/macros/Macros.h>
   #include <c10/util/Exception.h>
   #include <c10/util/SmallVector.h>
   #include <torch/headeronly/util/HeaderOnlyArrayRef.h>
   
   #include <array>
   #include <cstddef>
   #include <cstdint>
   #include <initializer_list>
   #include <iterator>
   #include <ostream>
   #include <type_traits>
   #include <vector>
   
   namespace c10 {
   template <typename T>
   class ArrayRef final : public HeaderOnlyArrayRef<T> {
    public:
   
     using HeaderOnlyArrayRef<T>::HeaderOnlyArrayRef;
   
     template <typename U>
     /* implicit */ ArrayRef(const SmallVectorTemplateCommon<T, U>& Vec)
         : HeaderOnlyArrayRef<T>(Vec.data(), Vec.size()) {}
   
   
     constexpr const T& front() const {
       TORCH_CHECK(
           !this->empty(), "ArrayRef: attempted to access front() of empty list");
       return this->Data[0];
     }
   
     constexpr const T& back() const {
       TORCH_CHECK(
           !this->empty(), "ArrayRef: attempted to access back() of empty list");
       return this->Data[this->Length - 1];
     }
   
     constexpr ArrayRef<T> slice(size_t N, size_t M) const {
       TORCH_CHECK(
           N + M <= this->size(),
           "ArrayRef: invalid slice, N = ",
           N,
           "; M = ",
           M,
           "; size = ",
           this->size());
       return ArrayRef<T>(this->data() + N, M);
     }
   
     constexpr ArrayRef<T> slice(size_t N) const {
       TORCH_CHECK(
           N <= this->size(),
           "ArrayRef: invalid slice, N = ",
           N,
           "; size = ",
           this->size());
       return slice(N, this->size() - N); // should this slice be this->slice?
     }
   
   
     constexpr const T& at(size_t Index) const {
       TORCH_CHECK(
           Index < this->Length,
           "ArrayRef: invalid index Index = ",
           Index,
           "; Length = ",
           this->Length);
       return this->Data[Index];
     }
   
     template <typename U>
     std::enable_if_t<std::is_same_v<U, T>, ArrayRef<T>>& operator=(
         // NOLINTNEXTLINE(cppcoreguidelines-missing-std-forward)
         U&& Temporary) = delete;
   
     template <typename U>
     std::enable_if_t<std::is_same_v<U, T>, ArrayRef<T>>& operator=(
         std::initializer_list<U>) = delete;
   
   };
   
   
   // Single element constructor
   template <typename T>
   ArrayRef(const T&) -> ArrayRef<T>;
   
   // Pointer and length constructor
   template <typename T>
   ArrayRef(const T*, size_t) -> ArrayRef<T>;
   
   // Range constructor (begin, end)
   template <typename T>
   ArrayRef(const T*, const T*) -> ArrayRef<T>;
   
   // Generic container constructor (anything with .data() and .size())
   template <typename Container>
   ArrayRef(const Container&) -> ArrayRef<
       std::remove_pointer_t<decltype(std::declval<Container>().data())>>;
   
   // std::vector constructor
   template <typename T, typename A>
   ArrayRef(const std::vector<T, A>&) -> ArrayRef<T>;
   
   // std::array constructor
   template <typename T, size_t N>
   ArrayRef(const std::array<T, N>&) -> ArrayRef<T>;
   
   // C array constructor
   template <typename T, size_t N>
   ArrayRef(const T (&)[N]) -> ArrayRef<T>;
   
   // std::initializer_list constructor
   template <typename T>
   ArrayRef(const std::initializer_list<T>&) -> ArrayRef<T>;
   
   
   template <typename T>
   std::ostream& operator<<(std::ostream& out, ArrayRef<T> list) {
     int i = 0;
     out << "[";
     for (const auto& e : list) {
       if (i++ > 0)
         out << ", ";
       out << e;
     }
     out << "]";
     return out;
   }
   
   
   template <typename T>
   ArrayRef<T> makeArrayRef(const T& OneElt) {
     return OneElt;
   }
   
   template <typename T>
   ArrayRef<T> makeArrayRef(const T* data, size_t length) {
     return ArrayRef<T>(data, length);
   }
   
   template <typename T>
   ArrayRef<T> makeArrayRef(const T* begin, const T* end) {
     return ArrayRef<T>(begin, end);
   }
   
   template <typename T>
   ArrayRef<T> makeArrayRef(const SmallVectorImpl<T>& Vec) {
     return Vec;
   }
   
   template <typename T, unsigned N>
   ArrayRef<T> makeArrayRef(const SmallVector<T, N>& Vec) {
     return Vec;
   }
   
   template <typename T>
   ArrayRef<T> makeArrayRef(const std::vector<T>& Vec) {
     return Vec;
   }
   
   template <typename T, std::size_t N>
   ArrayRef<T> makeArrayRef(const std::array<T, N>& Arr) {
     return Arr;
   }
   
   template <typename T>
   ArrayRef<T> makeArrayRef(const ArrayRef<T>& Vec) {
     return Vec;
   }
   
   template <typename T>
   ArrayRef<T>& makeArrayRef(ArrayRef<T>& Vec) {
     return Vec;
   }
   
   template <typename T, size_t N>
   // NOLINTNEXTLINE(*c-arrays*)
   ArrayRef<T> makeArrayRef(const T (&Arr)[N]) {
     return ArrayRef<T>(Arr);
   }
   
   // WARNING: Template instantiation will NOT be willing to do an implicit
   // conversions to get you to an c10::ArrayRef, which is why we need so
   // many overloads.
   
   template <typename T>
   bool operator==(c10::ArrayRef<T> a1, c10::ArrayRef<T> a2) {
     return a1.equals(a2);
   }
   
   template <typename T>
   bool operator!=(c10::ArrayRef<T> a1, c10::ArrayRef<T> a2) {
     return !a1.equals(a2);
   }
   
   template <typename T>
   bool operator==(const std::vector<T>& a1, c10::ArrayRef<T> a2) {
     return c10::ArrayRef<T>(a1).equals(a2);
   }
   
   template <typename T>
   bool operator!=(const std::vector<T>& a1, c10::ArrayRef<T> a2) {
     return !c10::ArrayRef<T>(a1).equals(a2);
   }
   
   template <typename T>
   bool operator==(c10::ArrayRef<T> a1, const std::vector<T>& a2) {
     return a1.equals(c10::ArrayRef<T>(a2));
   }
   
   template <typename T>
   bool operator!=(c10::ArrayRef<T> a1, const std::vector<T>& a2) {
     return !a1.equals(c10::ArrayRef<T>(a2));
   }
   
   using IntArrayRef = ArrayRef<int64_t>;
   
   using IntList [[deprecated(
       "This alias is deprecated because it doesn't make ownership semantics obvious. Use IntArrayRef instead!")]] =
       ArrayRef<int64_t>;
   
   } // namespace c10
